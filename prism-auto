#!/usr/bin/python

import os,sys,re,subprocess,signal
from optparse import OptionParser

#==================================================================================================
# Utility functions
#==================================================================================================

def isPrismModelFile(file):
	return re.match('.+(\.prism|\.nm|\.pm|\.sm)$', file)

def isPrismPropertiesFile(file):
	return re.match('.+(\.props|\.pctl|\.csl)$', file)

def isPrismModelListFile(file):
	return re.match('models$', os.path.basename(file))

def isPrismPropListFile(file):
	return re.match('.+(\.txt)$', file)

def lineIsCommentedOut(line):
	return line.startswith('#')

# Get a list of models in a directory, either from a "models" file if present or a list of all model files
# A "models" file is a list of (relative) path names, in which lines starting with # are ignored
# Each item of returned list is itself a list because the model specification may be in several parts,
# e.g. "model.sm", "-const", "N=2"
# Furthermore, the "model.args" for any file "model" is also read, if present,
# and any contained args are appended to the list

def getModelsInDir(dir):
	modelFiles = []
	if os.path.isfile(os.path.join(dir, "models")):
		for line in open(os.path.join(dir, "models"), 'r').readlines():
			line = line.strip()
			if len(line) == 0 or lineIsCommentedOut(line): continue
			modelFile = []
			for item in line.split(' '):
				if isPrismModelFile(item):
					modelFile.append(os.path.join(dir, item))
					modelFile += getArgsFromFile(item + ".args")
				else:
					modelFile.append(item)
			modelFiles.append(modelFile)
	else:
		for file in os.listdir(dir):
			if os.path.isfile(os.path.join(dir, file)) and isPrismModelFile(file):
				modelFiles.append([file] + getArgsFromFile(file + ".args"))
	return modelFiles

# Get a list of properties in a directory: just search for all files with an appropriate extension
# Return type is an array of strings (filenames)

def getPropertiesInDir(dir):
	propertiesFiles = []
	for file in os.listdir(dir):
		if os.path.isfile(os.path.join(dir, file)) and isPrismPropertiesFile(file):
			propertiesFiles.append(file)
	return propertiesFiles

# Extract command-line switches from an "args" file into a list
# Just combine switches on all (non-commented) lines together, delimited by spaces
# Returns an empty list if the file does not exist

def getArgsFromFile(file):
	args = []
	if not os.path.isfile(file): return args
	for line in open(file, 'r').readlines():
		line = line.strip()
		if len(line) == 0 or lineIsCommentedOut(line): continue
		items = line.split(' ')
		for item in items:
			if len(item) > 0: args.append(item)
	return args

# Extract command-line switches from a "bm" file into a list of lists
# Switches from each (non-commented) line, delimited by spaces, are in a separate list

def getArgsSetFromBMFile(file):
	argsSet = []
	if not os.path.isfile(file): return argsSet
	for line in open(file, 'r').readlines():
		args = []
		line = line.strip()
		if len(line) == 0 or lineIsCommentedOut(line): continue
		items = line.split(' ')
		for item in items:
			if len(item) > 0: args.append(item)
		if len(args) > 0: argsSet.append(args)
	return argsSet

def createLogFileName(args):
	logFile = '.'.join(args)
	logFile = re.sub('/', '_', logFile)
	logFile = re.sub('[^a-zA-Z0-9_=, \.]', '', logFile)
	logFile = re.sub('[ ]+', '.', logFile)
	logFile = re.sub('[\.]+', '.', logFile)
	logFile = re.sub('^[\._]+', '', logFile)
	return logFile + ".log"

# Walk a directory and execute a callback on each file

def walk(dir, meth):
	dir = os.path.abspath(dir)
	for file in [file for file in os.listdir(dir) if not file in [".","..",".svn"]]:
		nfile = os.path.join(dir, file)
		meth(nfile)
		if os.path.isdir(nfile):
			walk(nfile,meth)

#==================================================================================================
# Benchmarking
#==================================================================================================

# Run PRISM with a given list of command-line args

def runPrism(args):
	if options.echo:
		print ' '.join(args)
		return
	prismArgs = [options.prismExec] + args
	print ' '.join(prismArgs)
	if options.logDir:
		logFile = os.path.join(options.logDir, createLogFileName(args))
		f = open(logFile, 'w')
		exitCode = subprocess.Popen(prismArgs, stdout=f).wait()
		#exitCode = subprocess.Popen(prismArgs, cwd=dir, stdout=f).wait()
	else:
		exitCode = subprocess.Popen(prismArgs).wait()

# Run a benchmark, specified by a list of command-line args,
# possibly iterating over further lists of args from a "bm" file

def benchmark(args):
	# Loop through benchmark options, if required
	if options.bmFile and os.path.isfile(os.path.join(options.bmFile)):
		argsSet = getArgsSetFromBMFile(options.bmFile)
		for bmArgs in argsSet:
			runPrism(args + bmArgs)
	# If none, just use existing args
	else:
		runPrism(args)

# Execute benchmarking based on (possibly recursive) processing of a directory

def benchmarkDir(dir):
	# Recurse first, unless asked not to
	if not options.nonRec:
		for file in [file for file in os.listdir(dir) if not file in [".","..",".svn"]]:
			if os.path.isdir(os.path.join(dir, file)):
				benchmarkDir(os.path.join(dir, file))
	# Process files in dir
	modelFiles = getModelsInDir(dir)
	if len(modelFiles) > 0:
		print "Directory: " + dir
		for modelFile in modelFiles:
			# Models mode: just build
			if options.models:
				benchmark(modelFile)
			# Normal mode: run against all properties in dir
			else:
				propertiesFiles = getPropertiesInDir(dir)
				for propertiesFile in propertiesFiles:
					benchmark(modelFile + [propertiesFile])

# Execute benchmarking based on a single file (model, property, list)

def benchmarkFile(file):
	if isPrismModelFile(file):
		benchmarkModelFile(file)
	elif isPrismPropertiesFile(file):
		benchmarkPropertiesFile(file)
	elif isPrismPropListFile(file):
		benchmarkPropListFile(file)
	elif isPrismModelListFile(file):
		benchmarkModelListFile(file)

# Execute benchmarking based on a single model file
# i.e. just build the model

def benchmarkModelFile(modelFile):
	benchmark([modelFile] + getArgsFromFile(modelFile + ".args"))

# Execute benchmarking based on a single properties file
# i.e. just model check against all models in the same directory

def benchmarkPropertiesFile(propertiesFile):
	dir = os.path.dirname(propertiesFile)
	modelFiles = getModelsInDir(dir)
	for modelFile in modelFiles:
		benchmark(modelFile + [propertiesFile])

# Execute benchmarking based on ...

def benchmarkModelListFile(modelListFile):
	print "model list!"
	dirName = os.path.dirname(modelListFile)
	for line in open(modelListFile, 'r').readlines():
		print line.strip().split(' ')
		benchmark(dirName, line.strip().split(' '))

# Execute benchmarking based on a property list

def benchmarkPropListFile(propListFile):
	print "Property list: " + propListFile
	listDir = os.path.dirname(propListFile)
	for line in open(propListFile, 'r').readlines():
		line = line.strip()
		if len(line) == 0 or lineIsCommentedOut(line): continue
		items = line.split(',')
		dir = os.path.join(listDir, items[0].strip())
		dir = os.path.realpath(dir)
		print "Directory: " + dir
		propFile = items[1].strip()
		print "Property file: " + propFile
		benchmarkPropertiesFile(os.path.join(dir, propFile))

#==================================================================================================
# Main program
#==================================================================================================

def printUsage():
	print "Usage: prism-auto ..."

def signal_handler(signal, frame):
	sys.exit(1)

# Main program

signal.signal(signal.SIGINT, signal_handler)
parser = OptionParser(usage="usage: %prog [options] arg")
parser.add_option("-b", "--benchmark", dest="bmFile", default="", help="File to read benchmarking argument lists from")
parser.add_option("-l", "--log", dest="logDir", default="", help="Store PRISM output in logs in this directory")
parser.add_option("-m", "--models", action="store_true", dest="models", default=False, help="Look for models, not properties, in a directory")
parser.add_option("-e", "--echo", action="store_true", dest="echo", default=False, help="Just print out tasks, don't execute")
parser.add_option("-x", "--exec", dest="prismExec", default="prism", help="Script to execute [default=prism]")
parser.add_option("-n", "--non-recursive", action="store_true", dest="nonRec", default=False, help="Don't recurse into directories")
(options, args) = parser.parse_args()
if len(args) != 1:
	parser.print_help()
	sys.exit(1)
if options.logDir and not os.path.isdir(options.logDir):
	print "Log directory \"" + options.logDir + "\" does not exist"
	sys.exit(1)
if os.path.isdir(args[0]):
	benchmarkDir(args[0])
elif os.path.isfile(args[0]):
	benchmarkFile(args[0])
